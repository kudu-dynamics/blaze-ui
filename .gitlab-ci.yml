stages:
  - lint
  - build
  - test
  - deploy
  - cleanup

# FIXME it would be _nice_ if we could run branch pipelines _until_ branches become MRs, in which
# case we run MR pipelines. Cf. https://gitlab.com/gitlab-org/gitlab/-/issues/34756#note_282820625
# This may be possible starting with gitlab 13.7: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/38673
workflow:
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_MERGE_REQUEST_ID == null
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Not making these global variables because they would get overridden in multi-project pipelines
.variables: &variables
  # The base of this repo's docker registry
  REPO_DOCKER_REGISTRY: ${CI_REGISTRY_IMAGE}
  # The image name of blaze image
  BLAZE_IMAGE:
    ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/blaze/blaze
  # Enable buildkit for more efficient layer caching
  DOCKER_BUILDKIT: "1"

# TODO gitlab 13.5 pre-collapse debug/environment info sections to reduce log noise

# Potential build dependencies for the dind host
.script-bootstrap-dind: &script-bootstrap-dind
  - echo -e "section_start:`date +%s`:bootstrap[collapsed=true]\r\e[0KBootstrap build dependencies"
  - |
    if [ -f /etc/alpine-release ]; then
      apk add git coreutils python3
      apk add -X http://dl-cdn.alpinelinux.org/alpine/edge/testing time
    fi
  - echo -e "section_end:`date +%s`:bootstrap\r\e[0K"

# Print runner environment info for debugging
.script-before-info: &script-before-info
  - echo -e "section_start:`date +%s`:pre-env[collapsed=true]\r\e[0KEnvironment info (before_script)"
  - uname -a
  - env
  - ls -al
  - find . -maxdepth 1 \( ! -name . \) -print0 | sort -z | xargs -0 -x du -bhsc
  - df -h
  - date -Iseconds
  - |
    if type git >/dev/null; then
      pushd "$BLAZE_BINJA_API" >/dev/null && \
        { git log --color --decorate HEAD^..HEAD | cat || true;
          popd >/dev/null;
        } || true
    fi
  - |
    if type python3 >/dev/null; then
      python3 -c 'import binaryninja; print(binaryninja.core_version())' || true
    fi
  - echo -e "section_end:`date +%s`:pre-env\r\e[0K"

.dind:
  image: docker:dind
  tags:
    - dind
  timeout: 1h
  variables:
    <<: *variables
  before_script:
    - *script-bootstrap-dind
    - *script-before-info

.haskell-job:
  extends: .dind
  image: ${REPO_DOCKER_REGISTRY}/blaze-service:commit-${CI_COMMIT_SHA}
  # Skip .dind before_script, especially the environment info, since we don't
  # care about most of it after the build stage
  before_script:
    - *script-before-info

lint:
  stage: lint
  extends: .dind
  image: ${BLAZE_IMAGE}
  needs: []
  script:
    - hlint --color=always server/src server/test
  allow_failure: true

# We need 2 build jobs: one for branch pipelines and one for MR pipelines
# - build:branch pushes to
#   - ${image}:commit-${CI_COMMIT_SHA}
#   - ${image}:branch-${CI_COMMIT_REF_SLUG}
#   For instance, ${project}:branch-feature-foo and ${project}:commit-1a2b3c4...
# - build:detached pushes to
#   - ${image}:merge-${CI_MERGE_REQUEST_IID}
#   For instance, ${project}:merge-71
# In either case, we should first try pulling the latest image for this branch or MR,
# and if that fails, pull :latest. This ensures we have cached layers downloaded

build:branch:
  stage: build
  extends: .dind
  rules:
    - if: $CI_MERGE_REQUEST_IID == null
  needs: []
  script:
    - blaze_image=${REPO_DOCKER_REGISTRY}/blaze-service
    - squashed_blaze_image=${REPO_DOCKER_REGISTRY}/blaze-service/squashed
    - wheel_server_image=${REPO_DOCKER_REGISTRY}/blaze-wheel-server

    # Pull images for layer caching
    - echo -e "section_start:`date +%s`:docker-pull[collapsed=true]\r\e[0KPull docker images for caching"
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${blaze_image}:branch-${CI_COMMIT_REF_SLUG}" ||
      docker pull "${blaze_image}:latest" ||
      true
    - docker pull "${wheel_server_image}:branch-${CI_COMMIT_REF_SLUG}" ||
      docker pull "${wheel_server_image}:latest" ||
      true
    - echo -e "section_end:`date +%s`:docker-pull\r\e[0K"

    # Build images
    - echo -e "section_start:`date +%s`:docker-build\r\e[0KBuild docker images"
    - docker build --pull . -f Dockerfile --target main
      -t "${blaze_image}:commit-${CI_COMMIT_SHA}"
      -t "${blaze_image}:branch-${CI_COMMIT_REF_SLUG}"
    - docker build --squash --pull . -f Dockerfile --target minimal
      -t "${squashed_blaze_image}:commit-${CI_COMMIT_SHA}"
      -t "${squashed_blaze_image}:branch-${CI_COMMIT_REF_SLUG}"
    - docker build --pull . -f Dockerfile --target wheel-server
      -t "${wheel_server_image}:commit-${CI_COMMIT_SHA}"
      -t "${wheel_server_image}:branch-${CI_COMMIT_REF_SLUG}"
    - echo -e "section_end:`date +%s`:docker-build\r\e[0K"

    # Push images
    - echo -e "section_start:`date +%s`:docker-push[collapsed=true]\r\e[0KPush new docker images"
    - docker push "${blaze_image}:commit-${CI_COMMIT_SHA}"
    - docker push "${blaze_image}:branch-${CI_COMMIT_REF_SLUG}"
    - docker push "${squashed_blaze_image}:commit-${CI_COMMIT_SHA}"
    - docker push "${squashed_blaze_image}:branch-${CI_COMMIT_REF_SLUG}"
    - docker push "${wheel_server_image}:commit-${CI_COMMIT_SHA}"
    - docker push "${wheel_server_image}:branch-${CI_COMMIT_REF_SLUG}"

build:detached:
  stage: build
  extends: .dind
  rules:
    - if: $CI_MERGE_REQUEST_IID
  needs: []
  script:
    - blaze_image=${REPO_DOCKER_REGISTRY}/blaze-service
    - squashed_blaze_image=${REPO_DOCKER_REGISTRY}/blaze-service/squashed
    - wheel_server_image=${REPO_DOCKER_REGISTRY}/blaze-wheel-server

    # Pull images for layer caching
    - echo -e "section_start:`date +%s`:docker-pull[collapsed=true]\r\e[0KPull docker images for caching"
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${blaze_image}:merge-${CI_MERGE_REQUEST_IID}" ||
      docker pull "${blaze_image}:latest" ||
      true
    - docker pull "${wheel_server_image}:merge-${CI_MERGE_REQUEST_IID}" ||
      docker pull "${wheel_server_image}:latest" ||
      true
    - echo -e "section_end:`date +%s`:docker-pull\r\e[0K"

    # Build images
    - echo -e "section_start:`date +%s`:docker-build\r\e[0KBuild docker images"
    - docker build --pull . -f Dockerfile --target main
      -t "${blaze_image}:merge-${CI_MERGE_REQUEST_IID}"
    - docker build --squash --pull . -f Dockerfile --target minimal
      -t "${squashed_blaze_image}:merge-${CI_MERGE_REQUEST_IID}"
    - docker build --squash --pull . -f Dockerfile --target wheel-server
      -t "${wheel_server_image}:merge-${CI_MERGE_REQUEST_IID}"
    - echo -e "section_end:`date +%s`:docker-build\r\e[0K"

    # Push images
    - echo -e "section_start:`date +%s`:docker-push[collapsed=true]\r\e[0KPush new docker images"
    - docker push "${blaze_image}:merge-${CI_MERGE_REQUEST_IID}"
    - docker push "${squashed_blaze_image}:merge-${CI_MERGE_REQUEST_IID}"
    - docker push "${wheel_server_image}:merge-${CI_MERGE_REQUEST_IID}"
    - echo -e "section_end:`date +%s`:docker-push\r\e[0K"

# Likewise, we need 2 test jobs. The test:branch job uses the ${image}:commit-... image,
# and the test:detached uses the ${image}:merge-... image

test:branch:
  stage: test
  extends: .haskell-job
  rules:
    - if: $CI_MERGE_REQUEST_IID == null
  needs:
    - build:branch
  variables:
    <<: *variables
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - cd /blaze/build/blaze-ui/server
    - STACK_TEST_TIMEOUT=1800 ../.ci/scripts/run_stack_test.py

test:detached:
  stage: test
  extends: .haskell-job
  image: ${REPO_DOCKER_REGISTRY}/blaze-service:merge-${CI_MERGE_REQUEST_IID}
  rules:
    - if: $CI_MERGE_REQUEST_IID
  needs:
    - build:detached
  variables:
    <<: *variables
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - cd /blaze/build/blaze-ui/server
    - STACK_TEST_TIMEOUT=1800 ../.ci/scripts/run_stack_test.py

# If we just pushed to the default branch, tag the images as :latest and push

push:latest:
  stage: deploy
  extends: .dind
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success
    - when: manual
      allow_failure: true
  variables:
    <<: *variables
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - gitlab_blaze=${REPO_DOCKER_REGISTRY}/blaze-service/squashed
    - aws_blaze=${AWS_ECR_REGISTRY}/integrated_blaze_system/kudu/blaze-service
    - gitlab_wheel_server=${REPO_DOCKER_REGISTRY}/blaze-wheel-server
    - aws_wheel_server=${AWS_ECR_REGISTRY}/integrated_blaze_system/kudu/blaze-wheel-server

    # Set up AWS ECR credentials
    - echo -e "section_start:`date +%s`:aws-config[collapsed=true]\r\e[0KConfigure AWS credentials"
    - apk add aws-cli
    - aws configure set default.region "${AWS_DEFAULT_REGION}"
    - aws configure set aws_access_key_id "${AWS_ACCESS_KEY_ID}"
    - aws configure set aws_secret_access_key "${AWS_SECRET_ACCESS_KEY}"
    - echo -e "section_end:`date +%s`:aws-config\r\e[0K"

    # Pull this pipeline's images
    - echo -e "section_start:`date +%s`:docker-pull\r\e[0KPull latest docker images"
    - docker login -u "${CI_REGISTRY_USER}" -p "$CI_JOB_TOKEN" "$CI_REGISTRY"
    - docker pull "${gitlab_blaze}:commit-${CI_COMMIT_SHA}"
    - docker pull "${gitlab_wheel_server}:commit-${CI_COMMIT_SHA}"
    - echo -e "section_end:`date +%s`:docker-pull\r\e[0K"

    # Push :latest images to internal gitlab registry
    - echo -e "section_start:`date +%s`:docker-push-gitlab\r\e[0KPush latest docker images to gitlab"
    - docker tag "${gitlab_blaze}:commit-${CI_COMMIT_SHA}" "${gitlab_blaze}:latest"
    - docker push "${gitlab_blaze}:latest"
    - docker tag "${gitlab_wheel_server}:commit-${CI_COMMIT_SHA}" "${gitlab_wheel_server}:latest"
    - docker push "${gitlab_wheel_server}:latest"
    - echo -e "section_end:`date +%s`:docker-push-gitlab\r\e[0K"

    # Push :latest images to AWS ECR integration registry
    - echo -e "section_start:`date +%s`:docker-push-aws\r\e[0KPush latest docker images to blaze AWS ECR registry"
    - aws ecr get-login-password | docker login --username AWS --password-stdin "${AWS_ECR_REGISTRY}"
    - docker tag "${gitlab_blaze}:commit-${CI_COMMIT_SHA}" "${aws_blaze}:latest"
    - docker push "${aws_blaze}:latest"
    - docker tag "${gitlab_wheel_server}:commit-${CI_COMMIT_SHA}" "${aws_wheel_server}:latest"
    - docker push "${aws_wheel_server}:latest"
    - echo -e "section_end:`date +%s`:docker-push-aws\r\e[0K"

pages:
  extends: .haskell-job
  stage: deploy
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH && $CI_MERGE_REQUEST_ID == null
      when: on_success
    - if: $CI_MERGE_REQUEST_ID == null
      when: manual
      allow_failure: true
  variables:
    <<: *variables
    GIT_STRATEGY: none
    GIT_CLEAN_FLAGS: none
  script:
    - haddock_flags=(--no-haddock-deps)
    - pushd /blaze/build/blaze-ui/server
    - stack haddock "${haddock_flags[@]}"
    - docs_dir=$(stack path --local-doc-root "${haddock_flags[@]}")
    - popd
    - ls -al
    - ls -al public || true
    # Why is this next line necessary sometimes?
    - rm -rf public
    - mkdir public
    - |
      if [ -d "$docs_dir" ]; then
        (
          shopt -s nullglob
          cp -ar "$docs_dir"/{*.html,*.css,*.png,*.js,blaze-*,binaryninja-*,binary-analysis-*} public
        )
      else
        echo '<h1>No haddocks created</h1>' > public/index.html
      fi
        
  artifacts:
    paths:
      - public
    expire_in: 12 hours

cleanup:
  stage: cleanup
  when: always
  extends: .dind
  variables:
    GIT_STRATEGY: none
  script:
    - apk add --no-cache --update bash
    - "# Untag all images created by this pipeline so we don't waste space on CI runner"
    - |
      bash -c '
        images=(
          ${REPO_DOCKER_REGISTRY}/blaze-service
          ${REPO_DOCKER_REGISTRY}/blaze-service/squashed
          ${REPO_DOCKER_REGISTRY}/blaze-wheel-server
          )
        tags=()
        for image in "${images[@]}"; do
          tags+=(
            "${image}:commit-${CI_COMMIT_SHA}"
            "${image}:branch-${CI_COMMIT_REF_SLUG}"
            "${CI_MERGE_REQUEST_IID:+${image}:merge-${CI_MERGE_REQUEST_IID}}"
            "${CI_COMMIT_TAG:+${image}:tag-${CI_COMMIT_TAG}}"
            )
        done
        for i in "${!tags[@]}"; do if [ -z "${tags[$i]}" ]; then unset tags[$i]; fi; done
        echo "${tags[@]}"
        docker image rm "${tags[@]}" || true
      '
