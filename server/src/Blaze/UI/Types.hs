{-# LANGUAGE DataKinds #-}

module Blaze.UI.Types
  ( module Blaze.UI.Types
  ) where

import Blaze.UI.Prelude
import qualified System.Envy as Envy
import System.Envy (fromEnv, FromEnv)
import qualified Data.HashMap.Strict as HashMap
import qualified Blaze.Types.Pil.Checker as Ch
import Blaze.Types.Pil (Stmt)
import qualified Binja.Function as BNFunc
import qualified Data.Aeson.Types as Aeson
import Blaze.Function (Function)
import Blaze.UI.Types.Cfg (CfgTransport, CfgId)
import qualified Blaze.UI.Types.Constraint as C
import Blaze.Types.Cfg (CfNode, CallNode, Cfg)
import qualified Blaze.UI.Types.Cfg.Snapshot as Snapshot
import qualified Blaze.UI.Types.Poi as Poi
import Blaze.UI.Types.Poi (Poi)
import Blaze.UI.Types.BndbHash (BndbHash)
import Blaze.UI.Types.BinaryHash (BinaryHash)
import Blaze.UI.Types.Db (MonadDb(withDb))
import qualified Blaze.UI.Types.Db as Db
import Blaze.UI.Types.BinaryManager (BinaryManager, BinaryManagerStorageDir(BinaryManagerStorageDir))
import Blaze.UI.Types.Session (SessionId, ClientId)
import Blaze.UI.Types.HostBinaryPath (HostBinaryPath)
import Blaze.Pretty (Token)
import Blaze.Types.Cfg.Analysis (CallNodeRating, CallNodeRatingCtx)
import Blaze.UI.Types.CachedCalc (CachedCalc)
import System.Random (Random)
import qualified Data.HashSet as HashSet

data BinjaMessage a = BinjaMessage
  { clientId :: ClientId -- generated by client
  , hostBinaryPath :: HostBinaryPath
  , binaryHash :: BinaryHash
  , action :: a
  } deriving (Eq, Ord, Show, Generic, FromJSON, ToJSON)

data PendingChanges = PendingChanges
  { removedNodes :: [UUID]
  , removedEdges :: [(UUID, UUID)]
  -- Maybe TODO: add "addedNodes" and "addedEdges"
  } deriving (Eq, Ord, Show, Generic, FromJSON, ToJSON)

data PoiSearchResults = PoiSearchResults
  { callNodeRatings :: [(UUID, CallNodeRating)]
  , presentTargetNodes :: [UUID]
  } deriving (Eq, Ord, Show, Generic, FromJSON, ToJSON)

data ServerToBinja = SBLogInfo { message :: Text }
                   | SBLogWarn { message :: Text }
                   | SBLogError { message :: Text }

                   | SBCfg { cfgId :: CfgId
                           -- So plugin can easily warn if it's out of date
                           , bndbHash :: BndbHash
                           , poiSearchResults :: Maybe PoiSearchResults 
                           , pendingChanges :: Maybe PendingChanges
                           -- TODO: send cfg with text
                           , cfg :: CfgTransport [[Token]]
                           }

                   | SBSnapshot { snapshotMsg :: Snapshot.ServerToBinja }

                   | SBPoi { poiMsg :: Poi.ServerToBinja }

                   | SBConstraint { constraintMsg :: C.ServerToBinja }

                   | SBNoop
                   deriving (Eq, Ord, Show, Generic, FromJSON, ToJSON)

data BinjaToServer = BSConnect
                   | BSTextMessage { message :: Text }
                   | BSTypeCheckFunction { bndbHash :: BndbHash
                                         , address :: Word64
                                         }

                   | BSCfgNew
                     { bndbHash :: BndbHash
                     , startFuncAddress :: Word64
                     }
                   | BSCfgExpandCall
                     { cfgId :: CfgId
                     , callNode :: CallNode ()
                     , targetAddress :: Word64
                     }
                   | BSCfgRemoveBranch
                     { cfgId :: CfgId
                     , edge :: (CfNode (), CfNode ())
                     }
                   | BSCfgRemoveNode
                     { cfgId :: CfgId
                     , node :: CfNode ()
                     }
                   | BSCfgFocus
                     { cfgId :: CfgId
                     , node :: CfNode ()
                     }

                   | BSCfgConfirmChanges
                     { cfgId :: CfgId }

                   | BSCfgRevertChanges
                     { cfgId :: CfgId }

                   | BSSnapshot { snapshotMsg :: Snapshot.BinjaToServer }

                   | BSPoi { poiMsg :: Poi.BinjaToServer }

                   | BSConstraint { constraintMsg :: C.BinjaToServer }

                   | BSComment
                     { cfgId :: CfgId
                     , nodeId :: UUID
                     , stmtIndex :: Word64
                     , comment :: Text
                     }

                   | BSNoop

                   deriving (Eq, Ord, Show, Generic, FromJSON, ToJSON)

data FunctionDescriptor = FunctionDescriptor
  { name :: Text
  , address :: Int
  } deriving (Eq, Ord, Show, Generic)

instance ToJSON FunctionDescriptor
instance FromJSON FunctionDescriptor

newtype SWLogErrorArgs = SWLogErrorArgs { message :: Maybe Text }
  deriving (Eq, Ord, Show, Generic)

instance ToJSON SWLogErrorArgs
instance FromJSON SWLogErrorArgs


webOptions :: Aeson.Options
webOptions = Aeson.defaultOptions
             { Aeson.unwrapUnaryRecords = True
             , Aeson.tagSingleConstructors = True
             }

data ServerConfig = ServerConfig
  { serverHost :: Text
  , serverWsPort :: Int
  , serverHttpPort :: Int
  , sqliteFilePath :: FilePath
  , binaryManagerStorageDir :: BinaryManagerStorageDir
  } deriving (Eq, Ord, Show, Generic)

instance FromEnv ServerConfig where
  fromEnv _ = ServerConfig
    <$> Envy.env "BLAZE_UI_HOST"
    <*> Envy.env "BLAZE_UI_WS_PORT"
    <*> Envy.env "BLAZE_UI_HTTP_PORT"
    <*> Envy.env "BLAZE_UI_SQLITE_FILEPATH"
    <*> (BinaryManagerStorageDir <$> Envy.env "BLAZE_UI_BNDB_STORAGE_DIR")


data BlazeToServer = BZNoop
                   | BZImportantInteger Int
                   | BZTypeCheckFunctionReport BNFunc.Function Ch.TypeReport
                   | BZFunctionList [Function]
                   deriving (Eq, Ord, Show, Generic)

newtype Event = BinjaEvent BinjaToServer
              deriving (Eq, Ord, Show, Generic)

-- TODO: Maybe we should just use SessionState since they are almost the same.
data EventLoopCtx = EventLoopCtx
  { clientId :: ClientId
  , hostBinaryPath :: HostBinaryPath
  , binaryManager :: BinaryManager
  , binjaOutboxes :: TVar (HashMap ConnId (ThreadId, TQueue ServerToBinja))
  , cfgs :: TVar (HashMap CfgId (TVar (Cfg [Stmt])))
  , dbConn :: Db.Conn
  , activePoi :: TVar (Maybe Poi)
  , callNodeRatingCtx :: CachedCalc BndbHash CallNodeRatingCtx
  } deriving (Generic)

newtype EventLoopState = EventLoopState
  { binjaOutput :: [ServerToBinja]
  } deriving (Generic)

newtype EventLoopError = EventLoopError Text
  deriving (Eq, Ord, Show, Generic)

newtype EventLoop a = EventLoop { _runEventLoop :: ReaderT EventLoopCtx (ExceptT EventLoopError IO) a }
  deriving newtype ( Functor
                   , Applicative
                   , Monad
                   , MonadReader EventLoopCtx
                   , MonadError EventLoopError
                   , MonadIO
                   , MonadThrow
                   , MonadCatch
                   , MonadMask
                   )

instance MonadDb EventLoop where
  withDb m = do
    conn <- view #dbConn <$> ask
    Db.runSelda conn m

runEventLoop :: EventLoop a -> EventLoopCtx -> IO (Either EventLoopError a)
runEventLoop m ctx = runExceptT . flip runReaderT ctx $ _runEventLoop m

forkEventLoop :: EventLoop () -> EventLoop ThreadId
forkEventLoop m = ask >>= \ctx -> liftIO . forkIO . void $ runEventLoop m ctx

forkEventLoop_ :: EventLoop () -> EventLoop ()
forkEventLoop_ = void . forkEventLoop

debug :: Text -> EventLoop ()
debug =  putText

-- there are multiple outboxes in case there are multiple conns to same binary
data SessionState = SessionState
  { binaryPath :: HostBinaryPath
  , binaryHash :: BinaryHash
  , binaryManager :: BinaryManager
  , cfgs :: TVar (HashMap CfgId (TVar (Cfg [Stmt])))
  , binjaOutboxes :: TVar (HashMap ConnId (ThreadId, TQueue ServerToBinja))
  , eventHandlerThread :: TMVar ThreadId
  , eventInbox :: TQueue Event
  , dbConn :: Db.Conn
  , activePoi :: TVar (Maybe Poi)
  , callNodeRatingCtx :: CachedCalc BndbHash CallNodeRatingCtx
  } deriving (Generic)

emptySessionState
  :: HostBinaryPath
  -> BinaryHash
  -> BinaryManager
  -> Db.Conn
  -> CachedCalc BndbHash CallNodeRatingCtx
  -> STM SessionState
emptySessionState binPath binHash bm tconn ccCallRating
  = SessionState binPath binHash bm
    <$> newTVar HashMap.empty
    <*> newTVar HashMap.empty
    <*> newEmptyTMVar
    <*> newTQueue
    <*> return tconn
    <*> newTVar Nothing
    <*> return ccCallRating

newtype ConnId = ConnId UUID
  deriving (Eq, Ord, Show, Generic)
  deriving newtype (Hashable, Random)

newConnId :: IO ConnId
newConnId = randomIO

-- all the changeable fields should be STM vars
-- so this can be updated across threads
data AppState = AppState
  { serverConfig :: ServerConfig
  , binarySessions :: TVar (HashMap SessionId SessionState)
  , sessionConns :: TVar (HashMap SessionId (HashSet ConnId))
  , dbConn :: Db.Conn
  } deriving (Generic)

instance MonadDb (ReaderT AppState IO) where
  withDb m = do
    conn <- view #dbConn <$> ask
    Db.runSelda conn m
  
-- | Inserts a unique ConnId for a SessionId.
-- SessionIds can have multiple active connections if a single user opens multiple
-- copies of a BNDB.
addSessionConn :: SessionId -> ConnId -> AppState -> STM ()
addSessionConn sid cid st =
  readTVar tv >>= writeTVar tv . HashMap.alter (Just . f) sid
  where
    tv = st ^. #sessionConns
    f Nothing = HashSet.singleton cid
    f (Just s) = HashSet.insert cid s

cleanupSessionState :: SessionState -> IO ()
cleanupSessionState ss = do
  (outboxThreads, mehandler) <- atomically $ do
    outboxThreads <- fmap fst . HashMap.elems <$> readTVar (ss ^. #binjaOutboxes)
    (outboxThreads ,) <$> tryReadTMVar (ss ^. #eventHandlerThread)
  mapM_ killThread outboxThreads
  maybe (return ()) killThread mehandler
  return ()

cleanupBinjaOutbox :: ConnId -> SessionState -> IO ()
cleanupBinjaOutbox connId ss = do
  mOutboxThread <- atomically $ do
    m <- readTVar $ ss ^. #binjaOutboxes
    return $ fst <$> HashMap.lookup connId m
  maybe (return ()) killThread mOutboxThread

-- | Removes ConnId from all sessions and frees up sessions with no active connections.
cleanupClosedConn :: ConnId -> AppState -> IO ()
cleanupClosedConn cid st = do
  (sstates, affectedButNotAbandonedStates) <- atomically $ do
    sessConnsMap <- readTVar (st ^. #sessionConns)
    let (abondonedSids, affectedButNotAbandonedSids, sessConnsMap')
          = removeConnsAndReturnAbandonedSessions sessConnsMap
    writeTVar (st ^. #sessionConns) sessConnsMap'
    sstateMap <- readTVar (st ^. #binarySessions)
    let (abandonedSessionsStates, sstateMap') = removeSessionsAndReturnSessionStates abondonedSids sstateMap
        affectedButNotAbandonedStates
          = mapMaybe (`HashMap.lookup` sstateMap) affectedButNotAbandonedSids
    writeTVar (st ^. #binarySessions) sstateMap'
    return (abandonedSessionsStates, affectedButNotAbandonedStates)
  mapM_ (cleanupBinjaOutbox cid) affectedButNotAbandonedStates
  putText $ "Removed " <> show (length affectedButNotAbandonedStates) <> " outboxes"
  mapM_ cleanupSessionState sstates
  putText $ "Removed " <> show (length sstates) <> " abandoned session states"
  where
    -- returns (abandoned sids, affected but not abandoned sids, m)
    removeConnsAndReturnAbandonedSessions
      :: HashMap SessionId (HashSet ConnId)
      -> ([SessionId], [SessionId], HashMap SessionId (HashSet ConnId))
    removeConnsAndReturnAbandonedSessions = HashMap.foldlWithKey' f ([], [], HashMap.empty) where
      f :: ([SessionId], [SessionId], HashMap SessionId (HashSet ConnId))
        -> SessionId
        -> HashSet ConnId
        -> ([SessionId], [SessionId], HashMap SessionId (HashSet ConnId))
      f (abSids, affSids, m) sid conns
        | HashSet.member cid conns = let conns' = HashSet.delete cid conns in
            if HashSet.null conns' then
              (sid:abSids, affSids, m)
            else
              (abSids, sid:affSids, HashMap.insert sid conns' m)
        | otherwise = (abSids, affSids, m)

    removeSessionsAndReturnSessionStates
      :: [SessionId]
      -> HashMap SessionId SessionState
      -> ([SessionState], HashMap SessionId SessionState)
    removeSessionsAndReturnSessionStates sids m =
      ( mapMaybe (`HashMap.lookup` m) sids
      , foldl' (flip HashMap.delete) HashMap.empty sids
      )

initAppState :: ServerConfig -> Db.Conn -> IO AppState
initAppState cfg' conn = AppState cfg'
  <$> newTVarIO HashMap.empty
  <*> newTVarIO HashMap.empty
  <*> pure conn

lookupSessionState :: SessionId -> AppState -> STM (Maybe SessionState)
lookupSessionState sid st = do
  m <- readTVar $ st ^. #binarySessions
  return $ HashMap.lookup sid m
